<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yengas</title>
    <link>https://yengas.github.io/tr/categories/node.js/index.xml</link>
    <description>Recent content on Yengas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://yengas.github.io/tr/categories/node.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bir Satranç Oyunu, Node.JS ile İşlemler Arası İletişim ve İş Dağıtımı</title>
      <link>https://yengas.github.io/tr/nodejs-cpu-heavy-ipc/</link>
      <pubDate>Fri, 16 Aug 2019 12:00:00 +0300</pubDate>
      
      <guid>https://yengas.github.io/tr/nodejs-cpu-heavy-ipc/</guid>
      <description>

&lt;p&gt;Bu makalenin konusu, Facebook gruplarından birinde karşılaştığım güzel bir sorudan geliyor. Soru hem temel konularda bilgi sahibi olmayı, hem de kullanılacak aracı iyi tanımayı gerektiriyor. Bu konuda fikirlerimi kısa bir cevap olarak yazarsam, haksızlık ederim diye düşündüm. Aynı zamanda bir şeyler öğrenmek ve kod maymunluğu yapmak için eğlenceli bir konu bulmuş oldum. Ortaya bu makale ve github üzerinde yayınladığım &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example&#34;&gt;örnek kodlar&lt;/a&gt; çıktı. Soruya bakarak, esas konumuzu yavaş yavaş işleyelim.&lt;/p&gt;

&lt;h2 id=&#34;bir-satranç-oyunu&#34;&gt;Bir Satranç Oyunu&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://yengas.github.io/img/articles/selim-question.png&#34; alt=&#34;drawing&#34; style=&#34;width:70%; max-width: 600px; @media (min-width: 768px) { width: 50%; }&#34;/&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Anlaşıldığı üzere, arkadaş bir satranç oyunu yapıyor ve kullanıcıyı bilgisayara karşı yarıştırmak istiyor. Stockfish motorunu(hamle önerisi yapan bir program), uygulamalarını yayınladığı ortama kurmuş ve şimdi bunu Node.js socket sunucusu ile entegre ederken kafasında soru işaretleri var. Bu soruya bakınca aklımda ilişkili sorular uçuşmaya başlıyor:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bu motoru istemci tarafında çalıştırabilir miyim? Sunucu&amp;rsquo;da uğraşmamak, beni fazlaca mühendislikten kurtarır.&lt;/li&gt;
&lt;li&gt;Stockfish motorunu kendi kontrolümde, Node.js işlemim içerisinde çalıştırabilir miyim?&lt;/li&gt;
&lt;li&gt;Oldu da Node.js içerisinde çalıştırdım. Bunun bana CPU/Memory maliyeti ne olacak?&lt;/li&gt;
&lt;li&gt;Bu motor herhangi bir state tutuyor mu? Örn. bir kullanıcı oyuna başladı, başlangıç itibari ile tüm hamleleri sırası ile mi motora vermem lazım? Yoksa her istekte tüm tahta durumunu mu vermeliyim?&lt;/li&gt;
&lt;li&gt;Ne kadar kullanıcım olacak? Anlık aktif satranç oyunu sayısı kaç olabilir?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Araştırmaya koyulmam lazım. Her sorunun cevabı dizayn ettiğim sistemi değiştirebilir. Ama ilk önce bir duraksayıp, bu sorunun neden makale yazmaya değer olduğunu anlatayım.&lt;/p&gt;

&lt;h3 id=&#34;başka-birinin-kodu&#34;&gt;Başka Birinin Kodu&lt;/h3&gt;

&lt;p&gt;Projelerimizde ihtiyacımız olan özellikleri edinmek için başkalarının kodunu hep kullanıyoruz. Resim küçültüp, büyütmek için olabilir. PDF bir dosya çıktısı almak için olabilir. QRCode oluşturmak için olabilir. Bu tarz ihtiyaçlarımızı NPM çoğu zaman karşılıyor. Ama bazı ihtiyaçlarımızı karşılayacak kodlar, kütüphane olarak bulunmayabilir. Böyle durumlarda artık kendi projemizin dışına adım atmamız ve farklı yazılımlar/işlemler ile konuşmamız gerekiyor.&lt;/p&gt;

&lt;p&gt;Bu olaya işlemler arası iletişim (&lt;a href=&#34;https://stackoverflow.com/questions/40005935/which-kind-of-inter-process-communication-ipc-mechanism-should-i-use-at-which&#34;&gt;IPC&lt;/a&gt;) diyoruz. Eğer uygulamanın bir konsol arayüzü varsa, bu uygulama ile iletişim kurmak için ilk akla gelen şey; &amp;ldquo;komut çalıştırmak&amp;rdquo; oluyor. Evet bunu yapmak oldukca kolay, &lt;a href=&#34;https://nodejs.org/api/child_process.html&#34;&gt;child_process&lt;/a&gt; kullanılarak, istediğimiz programı, istediğimiz argümanlar ile başlatabiliriz. Başlayan programın stdin ve stdout &amp;ldquo;dosyalarını&amp;rdquo; kendi Node.js işlemimize bağlayarak da, istediğimiz gibi iletişim kurabiliriz.&lt;/p&gt;

&lt;p&gt;Bu yöntemle birlikte düşünülmesi gereken şeyler artıyor. Bizim kodumuzun çalıştığı her yerde, bu uygulamanın kurulu olması gerekiyor. Hem de aynı versiyon ve konfigürasyon ile. Kullanmak istediğimiz tüm özelliklerin komut satırı üzerinden sağlanıyor olması gerekiyor. Eğer kendi kodumun içine bu fonksiyonaliteyi gömebiliyorsam, bunlarla uğraşmak istemem.&lt;/p&gt;

&lt;p&gt;Neyse ki Stockfish durumunda, NPM üzerinde bir kütüphane &lt;a href=&#34;https://www.npmjs.com/package/stockfish&#34;&gt;bulunuyor&lt;/a&gt;. Ama bu seferde başka sorunlar ortaya çıkıyor. Bu kütüphanenin nasıl çalıştığını anlamam lazım. Satranç hamlesi önermek CPU ucuz bir işlem olmamalı. Ben bu kütüphaneden bir fonksiyon çağırdığımda, CPU kullanımından dolayı sunucum kitlenecek mi? Sonuçta Node.js tek thread ve tek CPU demek. Bu kütüphanedeki bir fonksiyon 1 saniye beni kitlerse, o 1 saniye hiç bir kullanıcım hizmet alamayacak demek. Böyle bir duruma engel olmak için de kendi projem içindeki fonksiyonaliteleri birden fazla işlem olarak çalıştırmam ve IPC yapmam gerekebilir.&lt;/p&gt;

&lt;p&gt;Soruların hepsi çok güzel. Araştırma yapmam lazım.&lt;/p&gt;

&lt;h2 id=&#34;stockfish-ve-satranç-hamle-önerisi&#34;&gt;Stockfish ve Satranç Hamle Önerisi&lt;/h2&gt;

&lt;p&gt;Üç taş oyunu gibi oyunları bilgisayara oynatmaya çalıştığımızda, bilgisayarın tüm ihtimalleri değerlendirmesi çok kısa sürer. Kazanan strateji de önceden belirlidir. Ama satranç gibi çok fazla ihtimal içeren kompleks oyunlarda, tüm ihtimalleri değerlendirmek imkansız. Bu yüzden Stockfish gibi satranç motorları, tahtanın şu anki durumu üzerinden, potansiyel hamlelerin ne kadar mantıklı olduğunu(hangi hamlelerin kaybetme ihtimalini azaltacağını) hesaplamak için geleceğe dönük bir arama yapar. Problemin doğası gereği, bu ucuz bir işlem değil ve CPU&amp;rsquo;nun ısınmasına sebep olabilir. Stockfish&amp;rsquo;i kendi Node process&amp;rsquo;im içerisinde çalıştırmak istiyorum. O yüzden bunu aklımda tutmam lazım.&lt;/p&gt;

&lt;p&gt;Ama ilk önce bu motor ile nasıl konuşacağıma, hamle önermek için benden ne isteyeceğine bakıyorum. İnternette kısa bir araştırma sonucunda, &lt;a href=&#34;https://chess.stackexchange.com/a/12581&#34;&gt;aradığımı&lt;/a&gt; buldum. &lt;a href=&#34;http://wbec-ridderkerk.nl/html/UCIProtocol.html&#34;&gt;Universal Chess Interface&lt;/a&gt; (UCI) adı verilen bir protokol sayesinde, Stockfish&amp;rsquo;e tahtamın şu anki durumunu veriyorum ve istediğim sayıda hamle önerisi alabiliyorum. En basit örnek şuna indirgenebilir:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position fen r3kb1r/p2npppp/2p2n2/3N4/8/5N2/PPPP1PPP/R1B2RK1 b kq - 0 10
go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kriptik görünen &lt;code&gt;r3kb1r/p2npppp/2p2n2/3N4/8/5N2/PPPP1PPP/R1B2RK1 b kq - 0 10&lt;/code&gt; kısmının &lt;a href=&#34;http://kirill-kryukov.com/chess/doc/fen.html&#34;&gt;açıklaması&lt;/a&gt; aslında oldukca &lt;a href=&#34;http://www.chessgames.com/fenhelp.html&#34;&gt;basit&lt;/a&gt;. &lt;em&gt;FEN&lt;/em&gt; adı verilen bu notasyon, tahtanın konumunu, sıranın hangi oyuncuda olduğu, kaçıncı hamle olduğunu gibi bilgileri barındırıyor. Önemli sorularımdan biri cevaplandı. Her hamle önerisinde, tahtanın tüm pozisyonunu Stockfish&amp;rsquo;e verebiliyorum ve &lt;a href=&#34;https://chess.stackexchange.com/a/12670&#34;&gt;önerilen&lt;/a&gt; bu. Bu demek oluyor ki, 1 tane motor çalıştırıp, eş zamanlı birden fazla kullanıcıya hizmet verebilirim. Motor herhangi bir state tutmuyor ve arka arkaya iki farklı oyunun FEN notasyonu verildiği zaman şaşırmıyor.&lt;/p&gt;

&lt;p&gt;Aynı zamanda araştırmalarımda Stockfish&amp;rsquo;in multi-thread çalışabildiği, düşünme zamanının kısıtlanabildiği, arama derinliğinin limitlenebildiği, önerilen hamle sayısının ayarlanabildiği, yetenek seviyesi ayarı bulunduğu gibi önemli bilgileri de edindim. Şimdi kod kısmına geçebilirim.&lt;/p&gt;

&lt;h2 id=&#34;node-js-stockfish-kütüphanesi&#34;&gt;Node.js Stockfish Kütüphanesi&lt;/h2&gt;

&lt;p&gt;Öğrendiklerimi kullanarak, Stockfish Node.js &lt;a href=&#34;https://www.npmjs.com/package/stockfish&#34;&gt;kütüphanesi&lt;/a&gt; ile hemen bir örnek yapıyorum.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const stockfish = require(&#39;stockfish&#39;)();

stockfish.onmessage = console.log;
stockfish.postMessage(&#39;uci&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu kodun çıktısı bana Stockfish motorunun opsiyonları ile ilgili bilgi veriyor. Örneğin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
option name Threads type spin default 1 min 1 max 1
option name MultiPV type spin default 1 min 1 max 500
option name Skill Level type spin default 20 min 0 max 20
option name Move Overhead type spin default 30 min 0 max 5000
option name Minimum Thinking Time type spin default 20 min 0 max 5000
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Burada ilgimi çeken şeylerden biri, &lt;em&gt;Threads&lt;/em&gt; opsiyonun olması, ama min ve max değerlerinin 1 olması. Muhtemelen Node.js ile alakalı bir şey. Kütüphanenin nasıl çalıştığını daha iyi anlamam lazım. Kütüphanenin açıklamasının başında &lt;code&gt;Stockfish.js is a pure JavaScript implementation of Stockfish&lt;/code&gt; yazıyor. Şimdi &lt;em&gt;pure Javascript&lt;/em&gt; denince kafam karıştı. Orjinali C++ olan bir motoru, sıfırdan Javascript ile mi yazmışlar? Öyle ise korkunç. Çünkü kim bilir ne eksikleri var? Ne kadar eski? Yüzlerce kişinin emeği olan C++ projesini, JS ile yeniden kaç kişi yazdı?&lt;/p&gt;

&lt;p&gt;Umutsuzluğa kapılmadan önce, projenin kaynak koduna bakıyorum. Neyse ki proje ağırlıklı C++ olarak görünüyor. &lt;a href=&#34;https://github.com/emscripten-core/emscripten&#34;&gt;emscripten&lt;/a&gt; ve WebAssembly kullanılarak, Javascript kütüphanesi haline getirilmiş. WebAssembly olduğu için &lt;em&gt;pure Javascript&lt;/em&gt; dendiğini düşünüyorum. Sonuçta C++ kod ile FFI kullanılarak iletişim kurulmuyor. Compile olan kod gerçekten Node.js&amp;rsquo;in kullandığı Javascript motoru ile çalıştırılıyor. Aynı zamanda kütüphane hem Node.js hem de tarayıcıyı destekliyor. Bir önemli sorum daha cevaplandı. Bu kütüphane ile web tarayıcısı üzerinde istemci tarafında da analiz yapabilirim(belki ileride React Native). Stockfish C++ olduğu için &lt;a href=&#34;https://github.com/akamai/stockfish-ios&#34;&gt;IOS&lt;/a&gt; ve &lt;a href=&#34;https://github.com/evijit/material-chess-android/tree/master/app/src/main/jni/stockfish&#34;&gt;Android&lt;/a&gt; üzerinde çalıştırmakta mümkün olabilir. Eğer Stockfish&amp;rsquo;i sunucu tarafında çalıştırırsam, kullanıcı sayısı arttıkca sunucu tarafındaki mühendislik ve kaynak gereksinimi de artacak. İstemci için aynı sorun yok. Belki arkadaşın ürünü için istemci daha mantıklı olabilir? Ben öyle olmadığını varsayıp, devam ediyorum :D&lt;/p&gt;

&lt;p&gt;Kütüphane ile ilgili araştırmamı sonlandırmadan önce bir kaç şey daha test etmek istiyorum.&lt;/p&gt;

&lt;h3 id=&#34;bootstrap-maliyeti&#34;&gt;Bootstrap Maliyeti&lt;/h3&gt;

&lt;p&gt;Bu kütüphanenin WebAssembly kullandığını öğrendim. Peki bu WebAssembly kütüphanesini &lt;em&gt;require&lt;/em&gt; etmek ne kadar maliyetli? Ve &lt;em&gt;dispose&lt;/em&gt; edebiliyor muyum? Yani işim bittiğinde, kullandığı kaynağı teslim etmesini ve yok olmasını sağlayabiliyor muyum? Hemen örnek bir kod ile deniyorum.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const stockfishCreator = require(&#39;stockfish&#39;);
const start = Date.now();
const stockfish = stockfishCreator();

stockfish.onmessage = line =&amp;gt; {
	if (line === &#39;readyok&#39;) console.log(Date.now() - start);
};
stockfish.postMessage(&#39;isready&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;UCI&lt;/em&gt; protokolüne göre, &lt;em&gt;isready&lt;/em&gt;&amp;lsquo;e &lt;em&gt;readyok&lt;/em&gt; ile cevap verilmesi lazım. Motor ayağa kalkar kalkmaz bu cevabı vermeli. Bu kodu çalıştırdığımda, ekranda gördüğüm çıktı 120 ms civarlarında. Bilgisayarım normal bir sunucudan daha hızlı. Bu başlangıç zamanı korkutucu. Aynı zamanda github üzerinde açık bir &lt;a href=&#34;https://github.com/nmrugg/stockfish.js/issues/14&#34;&gt;issue&lt;/a&gt; görüyorum. Birisi her Stockfish instance&amp;rsquo;ı oluşturduğunda 30 MB bir memory kullanımı olduğunu ve bu memory&amp;rsquo;i free edemediğini söylemiş. Bu da korkutucu. Nihai kararı vermeden önce bir şeyi daha araştırmak istiyorum.&lt;/p&gt;

&lt;h3 id=&#34;cpu-blok-kontrolü&#34;&gt;CPU blok kontrolü&lt;/h3&gt;

&lt;p&gt;Bu kütüphaneyi Node.js process&amp;rsquo;imize yüklediğim zaman, yaptığım çağrılar benim kodum ile aynı çekirdekte mi çalışıyor? Eğer öyle ise çok tehlikeli. Çünkü Stockfish 1 saniyelik bir düşünme sürecine girerse, Node process&amp;rsquo;im kitlenecek demek. Bunu kontrol edecek kodu hemen yazıyorum.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// her 500 ms&#39;de bir ping yazdır
setInterval(() =&amp;gt; console.log(&#39;ping&#39;), 500);
// 500 ms sonra, 1 kez stockfish fonksiyonu çağır
setTimeout(() =&amp;gt; stockfishCustom.getBestMove(&#39;...&#39;), 500);
// 2 saniye sonra, 10.000 kez, stockfish fonksiyonu çağır
setTimeout(() =&amp;gt; [...new Array(10000)].map(() =&amp;gt; stockfishCustom.getBestMove(&#39;...&#39;)), 2000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Burada gözlemlediğim şu: Ekrana 500 ms sonra bir kez &lt;em&gt;ping&lt;/em&gt; yazılıyor ve hemen ardından en iyi hamle yazılıyor. Bundan sonra 500 ms aralıklarla iki kez daha &lt;em&gt;ping&lt;/em&gt; yazılıyor ve anlık bir kitlenme yaşıyorum. Korktuğum şey başıma geldi. WebAssembly kodu, benim kodumu bloklayabiliyor. Yani bu kütüphaneyi kendi process&amp;rsquo;imden bağımsız çalıştırmak için takla atmam gerekicek. Bu &lt;a href=&#34;https://nodejs.org/api/worker_threads.html&#34;&gt;worker_threads&lt;/a&gt; kullanarak olabilir, &lt;a href=&#34;https://nodejs.org/api/cluster.html&#34;&gt;cluster#fork&lt;/a&gt; kullanarak olabilir, &lt;a href=&#34;https://nodejs.org/api/child_process.html&#34;&gt;child_process#fork&lt;/a&gt; kullanarak olabilir veya deployment sırasında kodumdan bağımsız bi process&amp;rsquo;i ayağa kaldırıp IPC yaparak olabilir. Bunların hepsini deneyeceğim ancak kütüphane ile ilgili aklıma takılan son bir konu daha var.&lt;/p&gt;

&lt;h3 id=&#34;yardımcı-fonksiyonlar&#34;&gt;Yardımcı Fonksiyonlar&lt;/h3&gt;

&lt;p&gt;İşlemler arası iletişim ve iş dağıtımı konularını konuşurken, &lt;em&gt;UCI&lt;/em&gt; veya kütüphane ile ilgili çok düşünmek istemiyorum. O yüzden hemen kendime yardımcı bir fonksiyon yazıyorum. Yapmak istediğim; satranç tahtasının durumu (&lt;em&gt;FEN&lt;/em&gt; string), motor yetenek seviyesi (0-20 arasında bir sayı) ve arama derinliği (sayı) verildiği zaman, bana en iyi hamleyi dönen bir fonksiyon. Bu fonksiyonun genel yapısı şöyle olucak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = () =&amp;gt; {
	const stockfish = require(&#39;stockfish&#39;)();
	
	function getBestMove(fen, level, depth) {
		// ...
		stockfish.postMessage(`... ${fen}`);
		// ...
		return Promise(resolve =&amp;gt; {
			// stockfish cevabını dinlemek için bir şeyler yap
		});
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Artık bu kodu şu şekilde kullanabilirim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { getBestMove } = require(&#39;./customStockfish.js&#39;)();
const bestMove = await getBestMove(&#39;...&#39;, 20, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tek aklımda tutmam gereken, bu kütüphaneyi her require edip çağırdığım zaman, yeni bir Stockfish instance&amp;rsquo;ı oluşacak. O yüzden bunu process başına 1 kez yapmak mantıklı. Bu yardımcı kodun tam implementasyonu &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/stockfish/index.js&#34;&gt;burada&lt;/a&gt; bulunabilir.&lt;/p&gt;

&lt;h2 id=&#34;kütüphaneyi-kullanmanın-farklı-stratejileri&#34;&gt;Kütüphaneyi Kullanmanın Farklı Stratejileri&lt;/h2&gt;

&lt;p&gt;Şimdi eğlenceli kısma gelebilirim. Bu kütüphaneyi farklı şekillerde nasıl kullanabilirim? Mimarim nasıl olacak? Kütüphanenin implementasyonu yüzünden, aynı anda birden fazla fonksiyon çağrısı yapamıyorum. Çünkü fonksiyon çağırma ve cevap alma birbirinden bağımsız. Yani &lt;code&gt;stockfish.postMessage()&lt;/code&gt; yapıyorum ama cevap string olarak &lt;code&gt;stockfish.onmessage&lt;/code&gt;&amp;lsquo;a verdiğim fonksiyona geliyor. Aynı Stockfish instance&amp;rsquo;ına paralelde birden fazla &lt;em&gt;postMessage&lt;/em&gt; yaparsam, bir şeylerin birbirine karışacağı aşikar. O yüzden kodumu yazarken bunu da hesaba katmam lazım. İlk önce ana Node.js işlemim içerisinde neler yapabiliyorum ona bakıyorum.&lt;/p&gt;

&lt;h3 id=&#34;her-istek-başına-stockfish-motoru&#34;&gt;Her İstek Başına Stockfish Motoru&lt;/h3&gt;

&lt;p&gt;Eğer Stockfish motorunu aynı anda birden fazla kez çağıramıyorsam, birden fazla Stockfish motorunu aynı anda birer kez çağırabilirim. Bunun kodu oldukça basit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const customStockfishCreator = require(&#39;../customStockfish&#39;);

module.exports = {
	async getBestMove(fen, level, depth) {
		const { getBestMove: realGetBestMove } = customStockFishCreator();
		const result = await realGetBestMove(fen, level, depth);
		
		return result;
	},
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Daha önce oluşturduğum yardımcı fonksiyon kütüphanesini kullanarak, her gelen istek için sıfırdan bir Stockfish motoru oluşturup, bu motor üzerinde tek bir istek yapabilirim.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await Promise.all([
	getBestMove(...),
	gttBestMove(...),
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yaptığım zaman, 2 tane stockfish motoru oluşur ve aynı anda istekleri işlerler. Araştırmamı yapmasaydım, bununla yetinebilirdim belki. Ama buradaki sorunları artık görebiliyorum.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Stockfish motoru oluşturmak ucuz bir işlem değil, her istek min 120 ms sürecek.&lt;/li&gt;
&lt;li&gt;Stockfish motoru her açıldığında Memory&amp;rsquo;de yer kaplıyor ve bunu free etmenin bir yolunu bulamadım.&lt;/li&gt;
&lt;li&gt;Stockfish motoru ana Node.js thread&amp;rsquo;im üzerinde çalışıyor. O yüzden bu iki motorun çalışması birbirini blocklayacak, birden fazla motor oluşturmak, avantajıma olmayacak.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bu yöntem az kullanıcı ile çalışabilir. Fakat kullanıcı sayısı artınca patlayacak. Bu &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example&#34;&gt;örnek projede&lt;/a&gt; rahatlıkla görülebilir. Örnek projeyi localinize çekin ve &lt;code&gt;npm run per_call:benchmark&lt;/code&gt; çalıştırın. Bu komut; bahsedilen strateji ile, eş zamanlı 1.000 tane hamle hesaplaması yapmaya çalışacak. Bilgisayarın RAM kullanımının artışı ve bir süre sonra işlemin patlaması seyredilebilir. Bu kütüphane için, bu yöntemi kullanmak mantıklı değil gibi&amp;hellip; Eğer Memory free etmenin bir yolunu bulsam ve yavaşlık benim için sıkıntı olmasa&amp;hellip; Belki kullanabilirdim?&lt;/p&gt;

&lt;h3 id=&#34;aynı-işlemde-tek-bir-stockfish-motoru&#34;&gt;Aynı İşlemde Tek Bir Stockfish Motoru&lt;/h3&gt;

&lt;p&gt;O zaman aynı işlem içinde uygulayabileceğim bir başka seçeneği deniyorum. Sadece bir tane Stockfish motorum olsun, ama her hamle hesaplama isteğini bir sıraya dizip, tek tek işleyeyim. Bunu bir array&amp;rsquo;e tüm istekleri pushlayıp, array&amp;rsquo;deki işleri işleyen bir fonksiyon ile yapabilirim. Ya da Promise chaining ile çok daha kolay ve temiz yapabilirim. Promise chaining ile ilerliyorum.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { getBestMove: realGetBestMove } = require(&#39;../customStockfish&#39;)();
let workChain = Promise.resolve();

module.exports = {
	async getBestMove(fen, level, depth) {
		return workChain = workChain.then(() =&amp;gt; realGetBestMove(fen, level, depth).catch(console.error));
	},
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu kadar basit. Tek bir Promise&amp;rsquo;im var. Her bir hamle hesaplama isteği geldiğinde, bu promise&amp;rsquo;in ucuna hamle öneri işlemi ekleyip, dönüyorum. Biraz kafa karıştırabilir. Ama bu şekilde, her bir hamle hesaplama isteği, sıralı şekilde çalışıyor. Yani artık:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;await Promise.all([
	getBestMove(...),
	getBestMove(...),
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yaptığım zaman, bu iki işlem paralel gibi gözükse de, aslında tek bir Stockfish motoru tarafından, tek tek işleniyor. Bunun da eksileri var.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Kullanıcı sayısı arttıkça, Stockfish motoru üzerinde iş birikecek ve cevap süresi artacak.&lt;/li&gt;
&lt;li&gt;Hala tek CPU üzerinde işlem yapıyorum. Stockfish motoru CPU&amp;rsquo;yu kilitleyip, sunucumu kötü etkileyebilir.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bu strateji için örnek projede eş zamanlı 10.000 hamle öneri işlemi yapmak için, &lt;code&gt;BENCHMARK_ANALYSIS_COUNT=10000 npm run single:benchmark&lt;/code&gt; komutu çalıştırılabilir. Benim bilgisayarımda yaklaşık 3 dakika sonra tüm işlemler bitiyor. Aynı işlemde bir kaç takla daha atarak iyileştirme yapmayı deneyebilirim. Örneğin 1. sorunu &amp;ldquo;çözmek&amp;rdquo; için, yukarıdaki dosyayı 1 kere require etmek yerine, birden fazla require edilebilecek hale getirebilirim ve her istekte round robin şekilde o motorlardan birine istek gönderirim. Ama tek CPU çalıştığım için bu bana fayda sağlamayacak. Artık tek işlemden kurtulup, birden fazla işlem ile çalışmam lazım.&lt;/p&gt;

&lt;h3 id=&#34;alt-işlemler-ile-birden-fazla-stockfish-motoru&#34;&gt;Alt İşlemler ile Birden Fazla Stockfish Motoru&lt;/h3&gt;

&lt;p&gt;Artık kararımı verdim. Stockfish motorum ana işlemim ile aynı CPU&amp;rsquo;yu kullanmayacak ve her işlem başına bir Stockfish motorum olacak. Peki bu Stockfish işlemlerini nasıl başlatabilirim? Ana işlem ile bu Stockfish motorları arasında nasıl iletişim kurabilirim? Bunun en basit yollarından biri, Node.js ile sunulan &lt;a href=&#34;https://nodejs.org/api/child_process.html&#34;&gt;child_process&lt;/a&gt; kütüphanesini kullanmak. Bu kütüphane, istediğim bir Javascript dosyasını, kendi işlemim ile arasında bir haberleşme köprüsü olacak şekilde çalıştırmamı sağlıyor. Ana işlemime Master, alt işlemlere Worker diyorum.&lt;/p&gt;

&lt;p&gt;Burada işi Workerlar arasında dağıtmak için farklı yöntemler kullanabilirim. Örneğin N adet Worker başlattım ve her birinde 1 adet Stockfish motoru çalıştırıyorum. Bunların hangilerinin müsait olduğunun takibini yaparım(şu anda hamle hesaplaması yapmıyor). Ana işlemde tüm istekleri biriktirip, müsait olan motora işlemleri sırasıyla veririm.&lt;/p&gt;

&lt;p&gt;Ya da bana gelen tüm işleri bir dağıtma stratejisi kullanarak(round robin, random, en az kaynak kullanan vs.) Stockfish motoru çalışan işlemlere gönderirim. Onlar sıralamayı kendi içerisinde yapar. Bu yöntemde kodum bir önceki bölüme çok benzeyecek. O yüzden bu yöntemi tercih ediyorum. Master&amp;rsquo;a gelen her istek, rastgele şekilde Workerlardan birine gönderilsin. Workerlar kendi içerisinde sıralı olarak işleyip, Mastera cevabı göndersin.&lt;/p&gt;

&lt;p&gt;İlk önce &lt;em&gt;worker.js&lt;/em&gt; kodum ile başlıyorum:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { getBestMove } = require(&#39;../customStockfish&#39;)();

async function findBestMoveAndSendReply({ id: workId, params: { fen, level, depth } }) {
	try {
		const reply = await getBestMove(fen, level, depth);
		
		process.send({ workId, reply });
	} catch(err) {
		// eğer bu işleme spesifik bir hata olursa, Promsie chain&#39;i durdurmak istemiyorum.
		console.error(&#39;there was an error when processing work:&#39;, err.message);
	}
}

let workChain = Promise.resolve();

process.on(&#39;message&#39;, workData =&amp;gt; {
	workChain = workChain.then(() =&amp;gt; (
		findBestMoveAndSendReply(workData)
	));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Burada kullanılan 2 fonksiyon Node.js&amp;rsquo;in sağladığı haberleşme köprüsünden geliyor. &lt;code&gt;process.on(&#39;message&#39;, ...)&lt;/code&gt; ana işlem&amp;rsquo;den bir istek geldiğinde çalışan fonksiyon. &lt;code&gt;process.send(...)&lt;/code&gt; ise ana işleme mesaj göndermek için kullandığım fonksiyon. Worker tarafı tamamdır. Bu &lt;em&gt;worker.js&lt;/em&gt; dosyasını &lt;code&gt;child_process.fork&lt;/code&gt; ile çalıştırdığım zaman, hamle önerisi hesaplama için iş göndermeye başlayabilirim. Ana işlemimden bağımsız şekilde çalışmaya başlayacak. Örnek projede &lt;em&gt;worker.js&lt;/em&gt; dosyasına &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/child_process/worker.js&#34;&gt;buradan&lt;/a&gt; erişilebilir.&lt;/p&gt;

&lt;p&gt;Şimdi işlem göndermek ile yükümlü olan koduma geliyorum. &lt;em&gt;master.js&lt;/em&gt; dosyasında workerlara iş dağıtmam lazım. Worker işlem başlatma kodunu şimdilik dışarıda tutuyorum. &lt;em&gt;master.js&lt;/em&gt; dosyasına Workerların başka yerden geldiğini kabul ederek kodluyorum.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const uuidv4 = require(&#39;uuid/v4&#39;);

const workWaitingMap = new Map();
const workers = [];

module.exports = {
	addWorker(worker) {
		workers.push(worker);
		
		// worker&#39;dan cevap geldiği zaman, bekleyen fonksiyonları çağırıyorum
		worker.on(&#39;message&#39;, action =&amp;gt; {
			const { workId, reply } = action;
			const waitingFunctions = workWaitingMap.get(workId);
			workWaitingMap.delete(workId);

			if (Array.isArray(waitingFunctions))
				waitingFunctions.forEach(func =&amp;gt; func(reply));
		});
	},
	addWork(params) {
		const workId = uuidv4();
		const work = { id: workId, params };
		const worker = workers[Math.floor(Math.random() * workers.length)];

		worker.send(work);
		return workId;
	},
	waitWorkReply(workId) {
		return new Promise((resolve) =&amp;gt; {
			if (!workWaitingMap.has(workId)) {
				workWaitingMap.set(workId, []);
			}

			workWaitingMap.get(workId).push(resolve);
		});
	},
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu kod biraz daha karmaşık görünüyor. Ama oldukça basit:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;addWorker&lt;/em&gt; fonksiyonu ile alt işlem referansını alıyorum. Bir dizi&amp;rsquo;de ileride kullanmak için saklıyorum ve gelen mesajlardan cevap çıkarıp, bu cevap için beklemekte olan fonksiyonları çağırıyorum.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;addWork&lt;/em&gt; fonksiyonuna verilen parametreler ile bir iş oluşturuyorum. İş oluştururken, random bir id atıyorum. Böylece Workerlardan cevap geldiği zaman, hangi işimin cevabı olduğunu takip edebileceğim(correlation id). Daha sonra da random bir Worker&amp;rsquo;a, bu işi gönderiyorum ve işin id&amp;rsquo;sini dönüyorum.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;waitWorkReply&lt;/em&gt; ise verilen id&amp;rsquo;li işin cevabını bekleyen bir promise döndürmek için kullanılıyor. Böylece iş gönderdikten sonra, cevabını beklemek için yardımcı bir fonksiyonum olmuş oldu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Artık &lt;code&gt;const workId = master.addWork({ fen: xxx, level: y, depth: z })&lt;/code&gt; diyerek bir iş oluşturabilirim ve cevabını almak için de &lt;code&gt;const bestMove = await master.waitWorkReply(workId)&lt;/code&gt; diyebilirim. Bunu tek fonksiyona da indirgeyebilirim.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getBestMove(fen, level, depth) {
	const workId = master.addWork({ fen, level, depth });
	
	return master.waitWorkReply(workId);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Şimdi yapmam gereken, &lt;em&gt;master.js&lt;/em&gt;&amp;lsquo;e ekleyeceğim Workerları oluşturmak. Birden fazla alt işlem olarak çalıştırmam lazım. Bunu uygulamamın başlangıcında yapabilirim. Kod şu şekilde:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const child_process = require(&#39;child_process&#39;);
const clusterMaster = require(&#39;../child_process/master&#39;);
const NUM_OF_WORKERS = 4;


for (let i = 0; i &amp;lt; NUM_OF_WORKERS; i++) {
	const worker = child_process.fork(require.resolve(&#39;../child_process/worker&#39;));

	clusterMaster.addWorker(worker);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;artık &lt;em&gt;clusterMaster&lt;/em&gt;&amp;lsquo;ı kullanarak hamle hesaplaması yapabilirim. Bu kodların çalışan hali &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/child_process/master.js&#34;&gt;master.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/child_process/master.js&#34;&gt;child_process/index.js&lt;/a&gt; ve &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/entrypoints/child_process.js&#34;&gt;entrypoints/child_process.js&lt;/a&gt; dosyalarında, örnek projede görülebilir. &lt;code&gt;BENCHMARK_ANALYSIS_COUNT=10000 npm run child_process:benchmark&lt;/code&gt; komutu çalıştırılarak test edilebilir. Bilgisayarımda eş zamanlı 10.000 hamlenin 20 saniyede hesaplandığını görüyorum.&lt;/p&gt;

&lt;p&gt;Performans artışı sağladım ve artık ana işlemimim Stockfish motoru ile kitlenmiyor. Bu kadar mühendislik yeterli olabilir. Ama bir kaç noktayı daha düşünüyorum.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Her ana işlem (Selim&amp;rsquo;in durumunda WebSocket sunucusu) kendisi ile birlikte N tane Stockfish motoru başlatıyor. Ama aynı makinede, birden fazla process olarak çalışıyorlar. Hala birbirlerinin çalışmasını etkileyebilirler.&lt;/li&gt;
&lt;li&gt;WebSocket sunucumu, Stockfish motorlarımdan bağımsız ölçekleyemiyorum. İkinci bir makinede Stockfish motoru çalıştırmak istersem, WebSocket sunucumu da orada çalıştırmam gerekiyor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Bunlar bir sorun olmayabilir. 4 çekirdekli bir sunucuda, 100 kullanıcıya hizmet verecek bir şeyler yapıyor olabilirim. Bu kadar mühendislik benim için yeterli olabilir. Ama uygulamamı yayınladığım ortam, kurulumum veya kullanıcı sayım böyle bir çözüm ile tatmin olmamama sebep olabilir. O yüzden bir strateji daha inceliyeceğim.&lt;/p&gt;

&lt;h3 id=&#34;bağımsız-işlemler-ile-birden-fazla-stockfish-motoru&#34;&gt;Bağımsız İşlemler ile Birden Fazla Stockfish Motoru&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://nodejs.org/api/child_process.html&#34;&gt;child_process&lt;/a&gt; kullanarak, ana işlemim ile aynı sunucuda, bağımlı işlemler başlatabiliyorum. Ama Stockfish motorlarını benim işlemimden tamamen bağımsız yapmak istersem ne ne yapacağım? 100 kullanıcım varken 3 motor, 1000 kullanıcım varken 10 motor çalıştırmak istiyorsam? Stockfish motorlarının donanım gereksinimleri farklı ise ve onları özel makinelerde çalıştırmak istiyorsam? Bunları sağlamak için, araya ağ katmanı koymam lazım. Örneğin Stockfish motorunu bir REST API haline getirebilirim veya herhangi bir queue teknolojisini, bu amaç için kullanabilirim(örn. &lt;a href=&#34;https://www.rabbitmq.com&#34;&gt;RabbitMQ&lt;/a&gt;, &lt;a href=&#34;https://redis.io/topics/pubsub&#34;&gt;Redis&lt;/a&gt;). Bunlar seçeneklerimden sadece birkaçı.&lt;/p&gt;

&lt;h4 id=&#34;rest-api-ile&#34;&gt;REST API ile&lt;/h4&gt;

&lt;p&gt;Stockfish motorunu ayrı bir işleme çıkartıp, bu işlemde REST API sunucusu ayağa kaldırabilirim. Böylece ana işlemim Stockfish motoru çalıştıran sunuculardan birine REST isteği gönderebilir ve en iyi hamle önerisini alabilir. Burada ana işlemimin, birden fazla Stockfish REST API çalıştırdığım zaman, hangisine istek atacağını nasıl bulacağı gibi bir sorun ortaya çıkıyor(Service Discovery). Bu sorunu deployment ortamına göre çözebilirim. &lt;em&gt;Kubernetes&lt;/em&gt; tarafında Service veya &lt;em&gt;nginx&lt;/em&gt; ile reverse proxy kullanmak gerekebilir. Şimdilik bunu unutalım.&lt;/p&gt;

&lt;p&gt;Bu şekilde ilerlemeyi seçersem, &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/260165f4bfac62b52858116b624417f7482034d9/rest/server.js&#34;&gt;server.js&lt;/a&gt; kodum:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fastify = require(&#39;fastify&#39;)();
const { getBestMove } = require(&#39;../stockfish&#39;)();

let workChain = Promise.resolve();

fastify.get(&#39;/chess&#39;, (request) =&amp;gt; {
	const { fen, level, depth } = request.query;

	return workChain = workChain.then(() =&amp;gt; getBestMove(fen, level, depth));
});

fastify.listen(process.argv[2]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ana &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/260165f4bfac62b52858116b624417f7482034d9/rest/index.js&#34;&gt;işlemimden&lt;/a&gt; bu sunucuya bir çağrı:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const axios = require(&#39;axios&#39;);

module.exports = () =&amp;gt; {
	return {
		async getBestMove(fen, level, depth) {
			let url = `http://localhost:8080/chess?fen=${encodeURIComponent(fen)}&amp;amp;level=${level}`;

			if (depth) url += `&amp;amp;depth=${depth}`;
			const { data: body } = await axios.get(url);
			return body;
		},
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;REST API sunucusundan istediğim kadar, istediğim sayıda makinede çalıştırabilirim. Tek yapmam gereken ana işlemime girdiğim &lt;code&gt;localhost:8080&lt;/code&gt; url&amp;rsquo;sini, load balancer URL&amp;rsquo;i ile değiştirmek. Load balancer çalışmakta olan REST API sunucularına yükü dağıtmakla yükümlü olucak. Demo&amp;rsquo;da load balancer yerine, N tane sunucu farklı portlarda başlatılıyor ve istek atılırken bu sunuculardan birinin portu rastgele seçiliyor.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BENCHMARK_ANALYSIS_COUNT=10000 npm run rest:benchmark&lt;/code&gt; komutu çalıştırılarak bu test edebilir. Benim makinemde 10.000 istekte, REST API sunucuları timeout vermeye başlıyor ve benchmark fail oluyor. 5.000 istekte 12 saniyede cevap alabiliyorum. Bunun sebebi REST API sunucularının tüm istekleri bir kerede üstüne alması ve sıralı işlem yaparken bu isteklerin timeout alması. Bu sorunun &lt;em&gt;fastify&lt;/em&gt; mı yoksa &lt;em&gt;axios&lt;/em&gt; tarafından mı kaynaklandığını çözemedim. Pratikte her sunucunun eş zamanlı 1.000 istek almayacağını varsaydığım için, bu yöntemi sıkıntılı olarak düşünmüyorum. Güzel bir kurulum ve daha iyi kod ile, sorun olmayacaktır.&lt;/p&gt;

&lt;h4 id=&#34;queue-teknolojisi-ile&#34;&gt;Queue Teknolojisi ile&lt;/h4&gt;

&lt;p&gt;REST API&amp;rsquo;ye alternatif olarak, Queue teknolojisi de kullanabilirim. Eğer kurulum ortamımda REST API ile yük dağıtımı yapmak zor olacaksa, bu iş için Queue&amp;rsquo;da kullanabilirim. Queue teknolojilerinin getirdiği &lt;a href=&#34;https://www.rabbitmq.com/features.html&#34;&gt;kolaylıklar&lt;/a&gt; ve &lt;a href=&#34;https://www.rabbitmq.com/tutorials/amqp-concepts.html&#34;&gt;soyutlamalar&lt;/a&gt; da işime yarayabilir. Küçük bir araştırma sonucunda, Redis kullanan ve ihtiyacım olan her şeyi basit bir API ile sağlayan &lt;a href=&#34;https://github.com/bee-queue/bee-queue&#34;&gt;bee-queue&lt;/a&gt; adında bir kütüphane buldum.&lt;/p&gt;

&lt;p&gt;Bu kütüphane ile &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/queue/worker.js&#34;&gt;worker.js&lt;/a&gt; kodu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const { getBestMove } = require(&#39;../stockfish&#39;)();
const queue = require(&#39;./createQueue&#39;)();

// .process fonksiyonu default olarak, aynı anda max 1 tane işlem çalıştırıyor.
queue.process(({ data: { fen, level, depth }}) =&amp;gt; (
	getBestMove(fen, level, depth)
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/queue/index.js&#34;&gt;master.js&lt;/a&gt; kodu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const createQueue = require(&#39;./createQueue&#39;);

module.exports = () =&amp;gt; {
	const queue = createQueue();

	return {
		getBestMove(fen, level, depth) {
			return new Promise((resolve, reject) =&amp;gt; {
				const job = queue.createJob({ fen, level, depth });

				job.save();
				job.on(&#39;succeeded&#39;, result =&amp;gt; resolve(result));
				job.on(&#39;error&#39;, err =&amp;gt; reject(err));
			});
		},
		close() {
			return queue.close();
		}
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/blob/ec3258455a3c276b1a460232e8aab97d7c55a6d6/queue/createQueue.js&#34;&gt;createQueue.js&lt;/a&gt; kodu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Queue = require(&#39;bee-queue&#39;);

module.exports = () =&amp;gt; {
	const { ip: host, port } = require(&#39;./config.json&#39;);

	return new Queue(&#39;chess&#39;, { redis: { host, port } });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sonuç&#34;&gt;Sonuç&lt;/h4&gt;

&lt;p&gt;REST API veya Queue farketmez, tek yapmam gereken, bu Master/Worker işlemleri birbirinden bağımsız şekilde çalıştırmak. Bunu &lt;a href=&#34;http://pm2.keymetrics.io/&#34;&gt;pm2&lt;/a&gt; kullanarak da yapabilirim, &lt;a href=&#34;https://aws.amazon.com/ecs/&#34;&gt;ECS&lt;/a&gt; kullanarak da, &lt;a href=&#34;https://kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; kullanarak da. Örneğin Kubernetes üzerinde WebSocket sunucusunu ve Stockfish workerlarını farklı deployment yapabilirim. Stockfish CPU kullanımı artınca otomatik ölçeklenmesini söyleyebilirim. Böylelikle kullanıcı sayısı arttıkça, WebSocket sunucumdan bağımsız olarak, Stockfish motorlarım ölçeklenebilir. Kod tarafı bu basitlikte iken, nasıl bir kurulum ortamım olduğuna göre, istediğim gibi ölçeklenebilirim.&lt;/p&gt;

&lt;p&gt;Aynı zamanda araya Node.js&amp;rsquo;e spesifik bir iletişim protokolü (&lt;em&gt;child_process&lt;/em&gt; IPC) değil de, ağ katmanı koyduğum için, Stockfish motorunu istediğim dilde çalıştırmak da oldukça kolay olacak. İstersem C++ ile bir proje yazarım ve ağ üzerinden erişirim, istersem Rust ile. Böylelikle belki tek bir motoru birden fazla CPU kullanacak hale getirebilirim? Kısaca faydalarından ve dezavantajlarından bahsetmek gerekirse;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ölçeklenmemi limitleyecek şey Queue teknolojim veya Load Balancer haline geldi. İstediğim kadar makinede, istediğim kadar Worker çalıştırabilirim. Queue/Load Balancer teknolojim, mesaj sayısını kaldırmayana kadar. Bu çoğu proje için ulaşılamayacak bir limit.&lt;/li&gt;
&lt;li&gt;Anlık yüke göre Stockfish motoru sayımı değiştirebilirim.&lt;/li&gt;
&lt;li&gt;WebSocket sunucusu ve Stockfish motorunu tamamen farklı makinelerde çalıştırabilirim.&lt;/li&gt;
&lt;li&gt;İstersem Node.js modülünü kullanmaya devam edebilirim, veya farklı bir dilde Stockfish motorunu kullanarak işlem yapabilirim.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Docker yüklü bilgisayarlarda &lt;code&gt;npm run queue:benchmark&lt;/code&gt; çalıştırarak, bu queue stratejisi denenebilir. REST API stratejisi için ise &lt;code&gt;npm run rest:benchmark&lt;/code&gt; çalıştırılabilir.&lt;/p&gt;

&lt;p&gt;Bu maddelere bağımlı olarak, deployment sürecim kompleksleşti. Queue durumunda ise yeni bir veritabanı bağımlılığım oldu. Bu dezavantajları kabullenip, böyle bir yapı kurmak, bazen bir seçenek olabilir. Ama bazen de zorunluluk haline gelebilir. Bu benim kişisel projem olsaydı, ben ne yapardım sorusuna aşağıda cevap veriyorum.&lt;/p&gt;

&lt;h2 id=&#34;nasıl-bir-mimari-yaparım&#34;&gt;Nasıl bir mimari yaparım?&lt;/h2&gt;

&lt;p&gt;Her zaman en iyi çözümü uygulamak, harcadığımız efora değmeyebilir. O yüzden eğer kişisel projem olsaydı, çözümleri şu sırada denerdim:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Yükümün az olduğunu varsayıyorum. WebSocket projesi içinde Stockfish modülünü kullanırdım. &lt;a href=&#34;https://nodejs.org/api/child_process.html&#34;&gt;child_process&lt;/a&gt; veya &lt;a href=&#34;https://nodejs.org/api/worker_threads.html&#34;&gt;worker_threads&lt;/a&gt; kullanarak Stockfish modülünü çalıştırırdım. Ama mesajlaşma yönetimini kendim yapmak yerine, &lt;em&gt;bee-queue&lt;/em&gt;&amp;lsquo;yu redis olmadan &lt;em&gt;worker_threads&lt;/em&gt;/&lt;em&gt;cluster&lt;/em&gt; ile çalıştırmayı denerdim.&lt;/li&gt;
&lt;li&gt;Yüküm arttı veya Stockfish JS&amp;rsquo;in düzgün çalışmadığını farkettim. Araya REST API koyardım. Bunu yapınca, benim için Stockfish&amp;rsquo;i Node.js ile çalıştırmanın bir anlamı kalmıyor. Bir Docker imajı oluşturup, içine C++ Stockfish motorunu koyardım. Node.JS veya C++ ile bu motor ile konuşup, REST API sunan bir kod yazardım. Kubernetes ile çalıştırarak load balancing ve auto scaling sorunlarını çözerdim. Demo&amp;rsquo;da eş zamanlı 10.000 istek sıkıntı yaratsa da, deployment sırasında güzel bir kurulum ve daha iyi kod ile sorunun çözülebileceğini düşünüyorum.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Eğer ağ üzerinden gönderilen veriler ve gelen cevaplar büyük olsaydı(fen, level, depth çok küçük), o zaman REST API yerine GRPC deneyebilirdim? Veya yeniden deneme stratejileri, işlerin Worker üzerinde birikmesi gibi sorunlar olsaydı Queue koymayı deneyebilirdim. Ne olursa olsun ilk önce basit başlar, ondan sonra yaşadığım sorunlara göre çözümler ve yeni bir mimari üretirdim.&lt;/p&gt;

&lt;h2 id=&#34;örnek-proje&#34;&gt;Örnek Proje&lt;/h2&gt;

&lt;p&gt;Bahsettiğim stratejilerin hepsini &lt;a href=&#34;https://github.com/Yengas/stockfish-cluster-example/tree/ec3258455a3c276b1a460232e8aab97d7c55a6d6&#34;&gt;örnek proje&amp;rsquo;de&lt;/a&gt; inceleyebilirsiniz. &lt;code&gt;npm run child_process:benchmark&lt;/code&gt; &lt;em&gt;child_process&lt;/em&gt; stratejisine 1.000 eş zamanlı hamle öneri isteği gönderiyor ve ne kadar sürdüğünü ekrana bastırıyor.&lt;/p&gt;

&lt;p&gt;Eğer &lt;code&gt;npm run child_process&lt;/code&gt; komutunu çalıştırırsanız, &lt;em&gt;child_process&lt;/em&gt; stratejisini kullanan bir WebSocket sunucusu başlatıyor. Bu WebSocket sunucusuna &lt;code&gt;npm run client&lt;/code&gt; diyerek bağlanıp, &lt;em&gt;FEN&lt;/em&gt; gönderebilirsiniz. Size o tahta durumu için, en iyi olduğunu düşündüğü hamleyi söylecek.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.JS Event Loop, Sync/Async, Promise, Async/Await ve RxJS üzerine...</title>
      <link>https://yengas.github.io/tr/nodejs-async/</link>
      <pubDate>Sat, 10 Mar 2018 03:28:00 +0300</pubDate>
      
      <guid>https://yengas.github.io/tr/nodejs-async/</guid>
      <description>

&lt;p&gt;Bu makalede Event Loop, Sync/Async, Promise, Async/Await, RxJS kavramlarını anlatmaya ve tüm bu kavramları tek bir örnek üzerinde kodlayarak göstermeye çalışacağım. Kendi sisteminizde denemeler yapmak istiyorsanız Node versiyonunuzun 8&amp;rsquo;in üzerinde olduğundan emin olun.&lt;/p&gt;

&lt;p&gt;Bu makalede yazılan tüm kodların, çalışır hallerine, &lt;a href=&#34;https://github.com/Yengas/async-blog-post&#34;&gt;yengas/async-blog-post&lt;/a&gt;@Github adresinden ulaşabilirsiniz.&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;İlk önce problemimiz ile başlayalım&amp;hellip; Elimde daha önce izlemek için kaydettiğim Ghibli filmlerinin id&amp;rsquo;leri var. Bu filmlerin hepsinin adını ve açıklamasını almak istiyorum.&lt;/p&gt;

&lt;p&gt;İlk önce elimdeki dosyanın formatına bakalım&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2baf70d1-42bb-4437-b551-e5fed5a87abe
12cfb892-aac0-4c5b-94af-521852e46d6a
58611129-2dbc-4a81-a72f-77ddfc1b1b49
ea660b10-85c4-4ae3-8a5f-41cea3648e3e
4e236f34-b981-41c3-8c65-f8c9000b94e7
ebbb6b7c-945c-41ee-a792-de0e43191bd8
1b67aa9a-2e4a-45af-ac98-64d6ad15b16c
ff24da26-a969-4f0e-ba1e-a122ead6c6e3
0440483e-ca0e-4120-8c50-4c8cd9b965d6
45204234-adfd-45cb-a505-a8e7a676b114
dc2e6bd1-8156-4886-adff-b39e6043af0c
90b72513-afd4-4570-84de-a56c312fdf81
cd3d059c-09f4-4ff3-8d63-bc765a5184fa
112c1e67-726f-40b1-ac17-6974127bb9b9
758bf02e-3122-46e0-884e-67cf83df1786
2de9426b-914a-4a06-a3a0-5e6d9d3886f6
45db04e4-304a-4933-9823-33f389e8d74d
67405111-37a5-438f-81cc-4666af60c800
578ae244-7750-4d9f-867b-f3cd3d6fecf4
5fdfb320-2a02-49a7-94ff-5ca418cae602
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Her satır, açıklamasını ve başlığını almak istediğim filmin id&amp;rsquo;sini ifade ediyor. Güzel&amp;hellip; Yeni satır karakteri &amp;lsquo;\n&amp;rsquo; ile, satırları birbirinden ayırmam yetecek. Ama ilk önce tüm listeyi işlemeye başlamadan önce, tek bir id için başlık ve açıklama alabileceğimden emin olmam lazım.&lt;/p&gt;

&lt;h2 id=&#34;tek-bir-film-sync-olarak-işlem-yapmak&#34;&gt;Tek bir film, sync olarak işlem yapmak.&lt;/h2&gt;

&lt;p&gt;Algoritma basit. Bir değişkende, bilgilerini bulmak istediğim filmin id&amp;rsquo;sini tutacağım, API&amp;rsquo;ye bir istek göndereceğim, gelen cevabı JSON olarak işleyip, obje&amp;rsquo;ye dönüştüreceğim, ve obje&amp;rsquo;min içindeki başlık ve açıklama bilgisini ekrana yazdıracağım! Tamamen düz mantık.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Sync olarak request yapmamızı sağlayacak, kütüphane.
const request = require(&#39;sync-request&#39;);
// bilgilerini almak istediğimiz filmin id&#39;si.
const movieID = &#39;2baf70d1-42bb-4437-b551-e5fed5a87abe&#39;;

// API&#39;ye yaptığımız istek
const result = request(&#39;GET&#39;, `https://ghibliapi.herokuapp.com/films/${movieID}`);
// API&#39;den gelen string cevabı, javascript objesini çevirmek için JSON parse işlemi
const body = JSON.parse(result.body.toString());
// obje içerisindeki title ve description değerlerinin, aynı isimle değişkene atanması.
const { title, description } = body;

// Artık sonucu ekrana yazdırabiliriz, umarız şimdiye kadar hata olmamıştır...
console.log(`Film Adı: ${title}`);
console.log(`Filmin açıklaması: ${description}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bu script&amp;rsquo;i çalıştırdığım zaman, çıktı olarak&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Film Adı: Castle in the Sky
Filmin açıklaması: The orphan Sheeta inherited a mysterious crystal that links her to the mythical sky-kingdom of Laputa. With the help of resourceful Pazu and a rollicking band of sky pirates, she makes her way to the ruins of the once-great civilization. Sheeta and Pazu must outwit the evil Muska, who plans to use Laputa&#39;s science to make himself ruler of the world.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;görüyorum. Tamda istediğimiz şey! Tek bir film id için, filmin başlığını ve açıklamasını aldık. Artık bir sonraki adıma geçip, tüm id&amp;rsquo;ler için bu işlemi yapabiliriz!&lt;/p&gt;

&lt;h2 id=&#34;birden-fazla-film-sync-olarak-işlem-yapmak&#34;&gt;Birden fazla film, sync olarak işlem yapmak.&lt;/h2&gt;

&lt;p&gt;Düz mantık devam ettiğim zaman, kodumda pek bir şey değişmemesi lazım. Tek yapmam gereken; tek bir film yerine, dosyamda bulunan her bir film için aynı kodu çalıştırmak. Kodumu düzenleyip, baktığımda, durum gerçektende böyle. Tek yapmamız gereken koda 2 şey eklemek oldu.&lt;/p&gt;

&lt;p&gt;Sabit bir film id&amp;rsquo;si yerine, tüm dosyayı okuyup, her satırı diziye atamak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Tüm film id&#39;lerini, dosyamızı okuyarak ve &#39;\n&#39; karakterinden split yaparak, bir diziye atıyalım.
const movieIDs = fs.readFileSync(&#39;../data/ghibli_movies.txt&#39;).toString().split(&#39;\n&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ve istek gönderdiğimiz satırdan itibaren, tüm kodumu, for/let of döngüsü içine almak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for(let movieID of movieIDs){
    const result = ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elimizdeki kodun son hali:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Dosya okumak için node.js kütüphanemizi alalım.
const fs = require(&#39;fs&#39;);
// Sync olarak request yapmamızı sağlayacak, kütüphane.
const request = require(&#39;sync-request&#39;);
// Tüm film id&#39;lerini, dosyamızı okuyarak ve &#39;\n&#39; karakterinden split yaparak, bir diziye atıyalım.
const movieIDs = fs.readFileSync(&#39;../data/ghibli_movies.txt&#39;).toString().split(&#39;\n&#39;);

for(let movieID of movieIDs){
  // API&#39;ye yaptığımız istek
  const result = request(&#39;GET&#39;, `https://ghibliapi.herokuapp.com/films/${movieID}`);
  // API&#39;den gelen string cevabı, javascript objesini çevirmek için JSON parse işlemi
  const body = JSON.parse(result.body.toString());
  // obje içerisindeki title ve description değerlerinin, aynı isimle değişkene atanması.
  const { title, description } = body;

  // Artık sonucu ekrana yazdırabiliriz, umarız şimdiye kadar hata olmamıştır...
  console.log(`Film Adı: ${title}`);
  console.log(`Filmin açıklaması: ${description}`);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sonuç olarak, artık kodumuz tüm film id&amp;rsquo;leri için başlık ve açıklamaları aldı ve bize gösterdi. Sorunumuz artık çözüldü. Bu problem için daha fazla kod yazmak gereksiz bile. Ama bir şeyi çok yanlış yapıyoruz. Bunu anlamak için, bir Node.js işleminin çalışma mantığına ve Event Loop&amp;rsquo;a değinelim.&lt;/p&gt;

&lt;h2 id=&#34;node-js-işlemi-ve-async&#34;&gt;Node.js işlemi ve Async&lt;/h2&gt;

&lt;p&gt;Yazdığımız Javascript kodunun, bir şekilde bilgisayarın anlayabileceği makine koduna dönüşmesi ve çalışması lazım. Tarayıcı&amp;rsquo;da bunu bizim için tarayıcının kendisi yaparken, Node.js kullanırken, &lt;code&gt;node &amp;lt;script_dosyamiz&amp;gt;.js&lt;/code&gt; komutunu kullanarak bu işlemi başlatıyoruz. Bu komut çalıştırıldığında, işletim sistemimiz&amp;rsquo;de, bizim Javascript kodumuzu çalıştıran bir işlem oluşuyor. Ve Node.js&amp;rsquo;in yardımları sayesinde, işletim sistemimizi kullanarak; dosya okuyabiliyoruz ve ağ üzerinden istekler gönderebiliyoruz.&lt;/p&gt;

&lt;p&gt;Buraya kadar olan kısım, şuana kadar yazdığımız kodu açıklıyor. Fakat burada daha optimize bir kod yazmamız için düşünmemiz gereken şey şu; bizim dosya okuma işlemimiz Harddisk veya SSD tarafından, ağ üzerinden yaptığımız istekler ise, ağ donanımımız üzerinden yapılıyor. Aslında sadece; dosyadan okuduğumuz değerleri diziye dönüştürmek, her bir dizi elemanı için yapılan istekleri &lt;code&gt;JSON.parse&lt;/code&gt; ile obje&amp;rsquo;ye dönüştürmek ve içerisindeki değerleri bu objeden çıkarıp, değişkene atamak için CPU&amp;rsquo;muzu kullanıyoruz.&lt;/p&gt;

&lt;p&gt;Ama kodumuzdaki düz mantığa geri döndüğümüzde, her bir isteğin gönderilmeden önce, bir önceki isteğin bitmesini ve ekrana yazdırılmasını beklediğimizi görüyoruz. Bu durumdan kurtulmak, şu anki problemimize baktığımızda; bütün programlama yöntemlerimizi değiştirmemize değmeyecek gibi görünsede, ideal bir dünyada yapmak istediğimiz şey; tüm bilgisayar donanımlarımızı optimal şekilde kullanmaktır.&lt;/p&gt;

&lt;p&gt;Yani, bir kullanıcınıza ağ üzerinden veri gönderirken, diğerinin sadece CPU kullanacak işlemini bekletmek istemezsiniz. Burada bizi kurtaracak olan terim Async. Async işlem yapmak demek, birden fazla iş parçacağının birbiri ile kesişen zamanlarda çalışabilmesi demektir. Node.JS için bu, &amp;ldquo;aynı anda&amp;rdquo; çalışmak anlamına gelmez.&lt;/p&gt;

&lt;p&gt;Şöyle örnek vermek gerekirse; biz ağ donanımımız işlem yaparken, CPU ile işlem yapabiliriz ama, CPU&amp;rsquo;muz birden fazla çekirdeğe sahip olsa bile, aynı anda 2 tane CPU gerektiren işlemi çalıştıramayız. Çünkü Node.JS bunu aynı işlem içinde desteklememektedir. Bu tek bir Node.js işleminin maksimum performans sınırını düşürmektedir. Fakat beraberinde birden fazla çekirdek kullanmanın getirebileceği sorunları çözmekte, ve bir çok async işleme kavramını kolaylaştırmaktadır. Sektörde Node.JS&amp;rsquo;in bu sorunu çözmek için ortaya attığı tek çekirdekli Async yapı dışında, birden fazla çekirdek ile ve async çalışmayı kolaylaştıran yazılım paradigmaları bulunmaktadır(örn. green threading, channels, functional programming).&lt;/p&gt;

&lt;p&gt;Çoğu basit seviyede uygulama, CPU&amp;rsquo;dan çok, diğer donanımları beklerken zaman harcamaktadır. Kaldı ki, bir Node.JS uygulamasında, sıkıntınız CPU olduğu zaman, birden fazla Node.JS işlemi çalıştırarak, birden fazla CPU kullanabilirsiniz. Burada dikkate alınması gereken durumlar tabiki olacaktır ama, bu bölümü kısa tutmak için, load balancing, state yönetimi gibi konulara girmek istemiyorum.&lt;/p&gt;

&lt;p&gt;Özet olarak, elimizdeki uygulamanın performansını iyileştirmek için, bir ağ isteği bitmeden, bir başkasını başlatabilir, ve ilk hangisi sonuçlanırsa onu işleyebiliriz. Ve bu işlem, Node.JS&amp;rsquo;in tek çekirdek kullanan yapısında, oldukca basit olacaktır.&lt;/p&gt;

&lt;h2 id=&#34;event-loop&#34;&gt;Event Loop&lt;/h2&gt;

&lt;p&gt;Bir farklı detayına girmek istemediğim, ve basitleştirme yaparak anlatmak istediğim konu ise, Event Loop. Node.JS çalışmak isteyen tüm fonksiyonları, kendi içinde bir sıraya koyar. Uygulamanızı ilk başlattığınız kod sayfanız, ilk çalışan fonksiyonunuz olarak düşünülür. Daha sonra, bu ana fonksiyonunuz içinde yaptığınız her &amp;ldquo;bloklayıcı(sync)&amp;rdquo; fonksiyon çağrısı, bitmesi beklenecek şekilde çalıştırılır. Eğer async olarak çalışacak olan bir fonksiyon çağrılırsa, bu async işlem bittiğinde çalışması için başka bir fonksiyon daha verebilirsiniz. Node.JS arkaplanda bu fonksiyonu sıraya koyarak, çalıştırmakta olduğu fonksiyona devam edecek, daha sonra çalışmakta olan fonksiyon ve async işlem bittikten sonra çalışması için verdiğiniz fonksiyonu çağırıcaktır.&lt;/p&gt;

&lt;p&gt;Bunu daha iyi anlayabilmek için basit bir örnek yapalım, daha sonra async programlama kısmına geçiş yapalım.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setTimeout(function yuzMilisaniyeSonra(){ console.log(&#39;1&#39;); }, 100);
setImmediate(function birSonrakiFonksiyon(){ console.log(&#39;2&#39;); });
setImmediate(function birSonrakiFonksiyon(){ console.log(&#39;4&#39;); });
console.log(&#39;start!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu kodu çalıştırdığımız zaman ekranda göreceğimiz çıktı:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start!
2
4
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;olacaktır. Tüm scriptimizi tek bir fonksiyon olarak kabul edelim. İlk önce 1. satır, &lt;code&gt;setTimeout&lt;/code&gt; fonksiyonu ile 100 milisaniye sonra çalışması için bir fonksiyonu sıraya koyuyoruz, &lt;code&gt;setImmediate&lt;/code&gt; ile event loop&amp;rsquo;a direk olarak 2 fonksiyonu arka arkaya ekliyoruz. Bu fonksiyonlar sadece Event Loop&amp;rsquo;a eklendi, ve daha çalışmadı. &lt;code&gt;setTimeout&lt;/code&gt; ve &lt;code&gt;setImmediate&lt;/code&gt; fonksiyonları sonlandıktan sonra, ana fonksiyonumuza hep geri dönüyoruz. Ve en son satırımızdaki &lt;code&gt;console.log&lt;/code&gt; fonksiyonu çağrılıp, ekrana &lt;code&gt;start!&lt;/code&gt; yazdırıldıktan sonra, sırasıyla Event Loop&amp;rsquo;daki fonksiyonlar çalışmaya başlıyor.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt; ile sıraya koyduğumuz fonksiyonumuz, 100 ms saniye geçmeden çalışamıyacağı için, sırasıyla event loop&amp;rsquo;a giren 2 yazdırma, 4 yazdırma fonksiyonları yazdırılıyor. Ve 100 ms geçtikten sonra ekrana 1 yazdırılıyor ve programımız sonlanıyor.&lt;/p&gt;

&lt;p&gt;İlk kodumuza döndüğümüz zaman, &lt;code&gt;fs.readFileSync(&#39;../data/ghibli_movieis.txt&#39;)&lt;/code&gt; satırımızı görebiliriz. Burada bu fonksiyon, dosya okuma işlemi bitene kadar, event loop&amp;rsquo;daki diğer fonksiyonların çalışmasını engellemiş oluyor. Hoş, bizim örneğimizde, event loopda başka bir fonksiyon olmadığı, ve programın çalışmaya devam etmesi için bu dosyayı okumamız gerektiği için bir önemi yok ama; &lt;code&gt;fs.readFile(&#39;../data/ghibli_movies.txt&#39;, function(err, data){ console.log(err, data); })&lt;/code&gt; yaparak; dosya okuma işlemini başlatıp, işlem bittikten sonra çağrılmak üzere bir fonksiyonu event loop&amp;rsquo;a ekleyebiliriz. Böylece dosya okuma işlemi, işletim sistemi tarafından, donanıma iletilir ve yapılırken, CPU ve Event Loop üzerinde başka fonksiyonlar çağırabiliriz. Alternatif olarak kısaca &lt;code&gt;fs.readFile(&#39;../data/ghibli_movies.txt&#39;, console.log);&lt;/code&gt;&amp;lsquo;da yapabiliriz. &lt;code&gt;console.log&lt;/code&gt;&amp;lsquo;da bir fonksiyon olduğu için, yazdığımız isimsiz fonksiyon gibi, dosya okuma işlemi bittikten sonra, sonuç parametreleri ile birlikte çağrılacaktır.&lt;/p&gt;

&lt;h2 id=&#34;promiseler-ve-async-await&#34;&gt;Promiseler ve Async/Await&lt;/h2&gt;

&lt;p&gt;Şimdi geldik, esas ilginç bölüme. Async değerler ile çalışmak için, Event Loop&amp;rsquo;a fonksiyon koymamız gerektiğini söyledik. Ama bunu eski, error first Node.js yöntemi ile yapmak zorunda değiliz. Çünkü bu yöntem, bizi; kod seviyesinde, Node.JS&amp;rsquo;in uydurduğu bir yapıya uymaya ve tüm async fonksiyonlara, standart tipte (hata, sonuç) tipinde parametreler kabul eden, fonksiyonlar vermeye zorluyor. Halbüki, sync çalışıyormuş gibi fonksiyonlar yazıp, sadece gerektiği yerde, async kavramları işin içine karıştırmamızı sağlayan bir yapı bulunmaktadır. Buna Promise denir.&lt;/p&gt;

&lt;p&gt;Örnek vermek gerekirse:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Bu fonksiyonun tek bildiği, Buffer tipiinde bir parametre aldığı ve her satırdan bir dizi oluşturması
function idListesineCevir(dosyaIcerigiBuffer){
	return dosyaIcerigiBuffer.toString().split(&#39;\n&#39;);
}

// bu fonksiyonu sync olarak kullanabiliriz.
idListesineCevir(fs.readFileSync(&#39;../data/ghibli_movies.txt&#39;))

// bu fonksiyonu async olarak callback ile kullanabiliriz
fs.readFile(&#39;../data/ghibli_movies.txt&#39;, function(err, buffer){
	if(err) ...
	const sonuc = idListesineCevir(buffer);
});

// bu fonksiyonu async olarak, Promise ile kullanabiliriz
// Buffer döndüren bir Promise&#39;i, Id listesi döndüren bir Promise&#39;e dönüştürür.
readFilePromise(&#39;../data/ghibli_movies.txt&#39;).then(idListesineCevir)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Burada dikkat çekmek istediğim şey, sync olarak bu fonksiyonumuzu kullandığımız zaman direk olarak, fonksiyon parametresi olarak Buffer veriyoruz. Promise kullanımı buna yakın ve temiz görünürken, eski tarz Node.js error first callback kullandığımız zaman, tamamen bu yapıya özel ekstra kod yazmamız gerekiyor. Error first callback kullanırken, hata olma durumunu kontrol etmek bizim sorumluluğumuzdayken, Promise&amp;rsquo;lerde başarılı sonuçlanma, ve hata durumları için ayrı fonksiyonlar tanımlayabiliyoruz. Aynı zamanda Promise&amp;rsquo;leri birbiri ardına bağlayarak kullanabilirken, error first callbackler ile bunu yapmak biraz daha uğraş verici oluyor.&lt;/p&gt;

&lt;p&gt;Örnek vermek gerekirse:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Promise veya callback olmadan, sync kullanım. Eğer bir hata olursa, exception throwlanır.
const ids = idListesineCevir(fs.readFileSync(&#39;../data/ghibli_movies.txt&#39;);
console.log(islemYap(ids[0]));

// zincirleme şekilde dosya okuma sonucunu id listesine çevir, ilk film id&#39;si için işlem başlat, sonucu ekrana yazdır
readFilePromise(&#39;../data/ghibli_movies.txt&#39;)
	.then(idListesineCevir)
	.then((ids) =&amp;gt; islemYap(ids[0]))
	.then(console.log)
	// Herhangi bir adımda hata oluşurse, bu fonksiyon çağırılacak.
	.catch(console.log);

// aynı işlemi callback ile yapmak istediğimizde sonuç:
fs.readFile(&#39;../data/ghibli_movies.txt&#39;, (err, buffer) =&amp;gt; {
	if(err) console.log(err);
	const id = idListesineCevir(buffer)[0];
	islemYap(id, function(err, result){
		if(err) return console.log(err);
		console.log(result);
	});
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yukarıdaki callback, daha düzgün bir şekilde, yeni fonksiyonlar tanımlanarak yazılabilir. Veya yardımcı bir kütüphane kullanılarak, daha düz hale getirilebilir, fakat&amp;hellip; Promiseler için en önemli ve kritik özellik, Node&amp;rsquo;un son versiyonlarında, kullanabilmeye başladığımız, async/await anahtar kelimeleri. Promise&amp;rsquo;ler, temelde düşünüldüğü zaman, sync fonksiyonlar ile async fonksiyonlar arasında bağlantı sağlayan, sync olarak parametre verilerek başlayan, gelecekte ya başarılı bir değer, ya da hata döndüren birer fonksiyondur.&lt;/p&gt;

&lt;p&gt;Promiselerin dönüş yapısı sync fonksiyonların exception throwlamasına benzetilebilir. Ve gelecekte değer döndürme belirtmek ve beklemek için özel anahtar kelimeler kullanılabilir. Async/Await tamamen bunu yapmak için yaratılmıştır. Basit anlamda düşünürsek, sizin sync&amp;rsquo;e benzer şekilde yazdığınız kodu, Promise&amp;rsquo;lerdeki &lt;code&gt;.then&lt;/code&gt; ve &lt;code&gt;.catch&lt;/code&gt; yapısına çevirir. Promise&amp;rsquo;ler ile tamamen uyumlu şekilde çalışırlar.&lt;/p&gt;

&lt;p&gt;Daha önceki örnekte bahsettiğim gibi, eğer bir Promise&amp;rsquo;e fonksiyon vererek, içinde sync işlem yapsanız bile, sonuçta elinizde gene bir Promise olacak. Async/Await&amp;rsquo;de bu mantıkla çalışmaktadır. Await kelimesi sadece async fonksiyonlar(yani Promise&amp;rsquo;ler) içinde kullanılabilir ve async fonksiyonlar Promise&amp;rsquo;den başka bir şey döndüremez.&lt;/p&gt;

&lt;p&gt;bir async fonksiyonun, promise olarak nasıl göründüğünü daha iyi anlıyalım.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function z(){
  return 4;
}
async function x(){
  const r = await z();
  const r2 = await z();
  return r + r2 + 5;
}

// async/await olmasaydı... iç içe .then yaptığımız bir promise gibi düşünebilirdik.
function x2(){
  return Promise.resolve().then(() =&amp;gt; z().then(r =&amp;gt; z().then(r2 =&amp;gt; r + r2 + 5)))
}

x().then(console.log)
x2().then(console.log)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hem x, hemde x2 fonksiyonu, sonuç olarak 13 döndürecektir.&lt;/p&gt;

&lt;p&gt;Async/Await hakkında bilgi sahibi olduktan sonra, yukarıdaki Promise ve Error First Callbacklere alternatif olarak, kodumuzu tekrar yazarsak;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function main(){
	const buffer = await readFilePromise(&#39;../data/ghibli_movies.txt&#39;);
	const id = idListesineCevir(buffer)[0];
	console.log(await islemYap(id)); 
}

// Main bir async fonksiyon, yani Promise olduğu için, .then ve .catch kullanabiliriz.
main().then(console.log).catch(console.log)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu kodun, ilk yazdığımız Sync örneğe ne kadar benzediğini kolayca görebilirsiniz. Async faydalarının hepsini Promise yapısını kullanarak, yine elde ediyoruz. Fakat, async/await kullanarak sync kod&amp;rsquo;a oldukca benzeyen bir yapıya sahip oluyoruz! Oldukca güzel bir özellik!&lt;/p&gt;

&lt;h2 id=&#34;async-olarak-tek-bir-film-ile-işlem-yapmak&#34;&gt;Async olarak, tek bir film ile işlem yapmak.&lt;/h2&gt;

&lt;p&gt;Şimdi problemimize geri dönelim. Yaptığımız işlemlerin sync olduğunu, ve async kullanmamız gerektiğini söylemiştik. Şimdi async/await kullanarak kodumuz tekrar yazalım.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// promise döndürecek şekilde async istek yapmamızı sağlayacak olan kütüphane.
const request = require(&#39;request-promise-native&#39;);

// sync benzeri kod yazabilmek için, async (promise döndüren) bir fonksiyon yazalım.
async function main(){
  const movieID = &amp;quot;2baf70d1-42bb-4437-b551-e5fed5a87abe&amp;quot;;

  // API&#39;ye yaptığımız istek
  const resultStr = await request(`https://ghibliapi.herokuapp.com/films/${movieID}`);
  // API&#39;den gelen string cevabı, javascript objesini çevirmek için JSON parse işlemi
  const body = JSON.parse(resultStr);
  // obje içerisindeki title ve description değerlerinin, aynı isimle değişkene atanması.
  const { title, description } = body;

  // Artık sonucu ekrana yazdırabiliriz.
  console.log(`Film Adı: ${title}`);
  console.log(`Filmin açıklaması: ${description}`);
}

// main fonksiyonunu çalıştır, ve dönen promise değerinde sonuç ve hata olması durumunda, konsola çıktı ver.
main().then(console.log, console.log);
// main fonksiyonunun bloklamadığını kanıtlamak için, ekrana yazı yazalım.
console.log(&#39;Main fonksiyonu çağrıldı!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu scripti çalıştırdığımız zaman, çıktı olarak gözlemleyeceğimiz şey;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Main fonksiyonu çağrıldı!
Film Adı: Castle in the Sky
Filmin açıklaması: The orphan Sheeta inherited a mysterious crystal that links her to the mythical sky-kingdom of Laputa. With the help of resourceful Pazu and a rollicking band of sky pirates, she makes her way to the ruins of the once-great civilization. Sheeta and Pazu must outwit the evil Muska, who plans to use Laputa&#39;s science to make himself ruler of the world.
undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Burada görüldüğü üzere, &lt;code&gt;Main fonksiyonu çağrıldı!&lt;/code&gt; yazısı, main fonksiyonu çağrıldıktan sonra yazılmış olsa bile, main fonksiyonu bloklamadığı için, ilk önce bu yazıyı görüyoruz. Daha sonra ağ isteğimiz sonuçlanıyor, film bilgileri yazdırılıyor ve main fonksiyonumuzun döndürdüğü Promise sonlanıyor. Main fonksiyonundan herhangi bir değer döndürmediğimiz için, sonuç undefined oluyor ve &lt;code&gt;.then&lt;/code&gt; fonksiyonunda bu undefined değeri ekrana yazdırılıyor.&lt;/p&gt;

&lt;p&gt;İlk sync versiyonumuza çok benzer bir şekilde, ağ işlemi; async olan bir kod yazmış olduk.&lt;/p&gt;

&lt;h2 id=&#34;async-olarak-birden-fazla-film-ile-işlem-yapmak&#34;&gt;Async olarak, birden fazla film ile işlem yapmak&lt;/h2&gt;

&lt;p&gt;İşlerin biraz kafa karıştırıcı hal aldığı durum burası. Aync/await kodun sync&amp;rsquo;e benzerliği sayesinde, kolayca birden fazla filmi async olarak işleyebiliriz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Dosya okumak için node.js kütüphanemizi alalım.
const fs = require(&#39;fs&#39;);
// node.js error-first callbackleri Promise&#39;e çevirmemize yardımcı olan fonksiyon
const { promisify } = require(&#39;util&#39;);
// readFile error first async fonksiyonunu, promise döndürecek şekilde çeviriyoruz.
const readFilePromise = promisify(fs.readFile);
// promise döndürecek şekilde async istek yapmamızı sağlayacak olan kütüphane.
const request = require(&#39;request-promise-native&#39;);

// sync benzeri kod yazabilmek için, async (promise döndüren) bir fonksiyon yazalım.
async function main(){
  // Dosya okuyan async kodu başlatalım, sonuctaki her bir satırı, dizi elemanı olarak alalım.
  const movieIDs = (await readFilePromise(&#39;../data/ghibli_movies.txt&#39;)).toString().split(&#39;\n&#39;);

  // Her bir dizi elemanı için async olarak istek gönderelim.
  for(let movieID of movieIDs){
    // API&#39;ye yaptığımız istek
    const resultStr = await request(`https://ghibliapi.herokuapp.com/films/${movieID}`);
    // API&#39;den gelen string cevabı, javascript objesini çevirmek için JSON parse işlemi
    const body = JSON.parse(resultStr);
    // obje içerisindeki title ve description değerlerinin, aynı isimle değişkene atanması.
    const { title, description } = body;

    // Artık sonucu ekrana yazdırabiliriz.
    console.log(`Film Adı: ${title}`);
    console.log(`Filmin açıklaması: ${description}`);
  }
}

// main fonksiyonunu çalıştır, ve dönen promise değerinde sonuç ve hata olması durumunda, konsola çıktı ver.
main().then(console.log, console.log);
// main fonksiyonunun bloklamadığını kanıtlamak için, ekrana yazı yazalım.
console.log(&#39;Main fonksiyonu çağrıldı!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu kodu çalıştırdığımızda, ağ işleminin async olmasına rağmen, beklediğimizden yavaş çalıştığını göreceğiz. Hani async sayesinde birden fazla ağ isteğini aynı anda yapabilecektik? İlk geleni işleyecektik? Buradaki sıkıntı async/await&amp;rsquo;in, promise&amp;rsquo;e dönüştürülürken, takip etmesi gereken adımlar. Şuanda bu yapı ile özet olarak şu şekilde bir yapıya sahip oluyoruz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let promise = Promise.resolve();
for(let movieID of movieIDs){
    promise = promise.then(() =&amp;gt; request(...movieID)).then((result) =&amp;gt; ...));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yani tek bir Promise zinciri oluşturuluyor. Bu yüzden network isteklerimizden biri bitmeden, bir sonraki başlamıyor. Burada uygulamanın yavaş çalışmasına rağmen, not düşmek istediğim bir konu var. Tüm ağ isteklerini, sırayla başlatmak yerine, hepsini aynı anda başlatabiliriz. Ama bu bizim Node.js uygulamamızı blokladığımız zamanı değiştirmeyecek. Sadece bu işlemin daha hızlı sonlanmasını/toplamda daha az zaman almasını sağlayacak. Burada ne demek istiyorum?&lt;/p&gt;

&lt;p&gt;Diyelim ki, her gönderdiğimiz istek 300 milisaniye alıyor, ve gelen cevabın işlenip ekrana yazdırılması ise 10 ms sürüyor. 300 milisaniyelik ağ isteği async olduğu için, nodejs işlemimiz bu ağ isteği gönderildikten sonra, çalışmasına devam edebilir, başka bir yerde, CPU harcayan bir kodunuz varsa(şuan bizim scriptimizde yok) onu çalıştırabilir. Ama ağ isteğinden cevap geldikten ve sıra işleme/yazdırma kodumuza geldiğinde 10 ms boyunca CPU&amp;rsquo;yu bu fonksiyonumuz bloklayacak. Daha sonra 300 milisaniye süren, yeni bir ağ isteği başlatılacak, ve yine CPU kullanmak isteyen farklı bir kod parçacağı varsa o çağrılabilecek. Yani biz aslında bu kod ile, her film id&amp;rsquo;si için sadece 10 milisaniye bloklamış oluyoruz. Ve toplam CPU bloklama süremiz, &lt;code&gt;10 * film id sayısı&lt;/code&gt; milisaniye oluyor. Fakat algoritmamız: &lt;code&gt;ağ isteği gönder, cevabın gelmesini bekle, işle ve yazdır, ağ isteği gönder...&lt;/code&gt; şeklinde olduğu için, toplam işlem süremiz:  &lt;code&gt;(300 + 10) * film id sayısı&lt;/code&gt; milisaniye oluyor.&lt;/p&gt;

&lt;p&gt;Bu durumu, algoritmamımızı: &lt;code&gt;bir filmid için; ağ isteği başlatıp, sonucu işleyen ve yazdıran bir promise zinciri oluştur, tüm film id için bu promise zincirlerini aynı anda başlat&lt;/code&gt; şeklinde değiştirirsek, bloklama süremiz yine değişmeyecek. Her işlemi işlemesi ve yazdırması 10 milisaniye süreceği için, gene &lt;code&gt;10 * film id sayısı&lt;/code&gt; milisaniye CPU bloklamış olacağız. Fakat ağ istekleri aynı anda başlatıldığı için, hepsi farklı sürede bitecek, ve en uzun süren isteğin 500 ms olduğunu varsayarsak, &lt;code&gt;500 + (10 * film id sayısı)&lt;/code&gt; milisaniye sonra, programımız sonlanmış olacak. Bu da script&amp;rsquo;in çalışma süresinde çok büyük bir düşüşe sebep olmuş olacak. Hatta kendi bilgisayarımdan ve internet bağlantımdan örnek vermem gerekirse; şuanki kod 25 saniyede çalışırken, optimize edilmiş şekilde yazdığım kod, 1.5 saniye sürüyor. 20 tane film id&amp;rsquo;si olduğunu varsayarsak, demek ki tek bir isteğin sonuçlanması ortalama 1.25 saniye sürüyor, ve tüm ağ isteklerini aynı anda başlattığımda, en uzun süren işlem 1.5 saniye tutuyor. Burada unutmamamız gereken, bloklama süresinin iki örnek içinde aynı olduğu. Yani eğer ağ istekleri 10 milisaniye tutsaydı, ve CPU işlemleri 1.5 saniye tutsaydı, iki örnekte benzer sürede bitecekti.&lt;/p&gt;

&lt;p&gt;Bu işlemin, daha hızlı biten versiyonunu yazabilmek için async/await fonksiyonları ile Promise bilgilerimizi birbiri ile birleştirip, ortaya bir karışım çıkarmamız gerkiyor. Bundan önce, uygulamamızı fonksiyonlara ayrıştırıp, kodumuzu daha düzenli hale getirelim. Ve son olarak, promise ile daha performanslı olarak yazmaya çalışalım.&lt;/p&gt;

&lt;h3 id=&#34;fonksiyonlara-ayrıştırmak&#34;&gt;Fonksiyonlara ayrıştırmak&lt;/h3&gt;

&lt;p&gt;Sync veya Async nasıl kodlarsak kodlayalım, uygulamamızın bazı kısımları tamamen saf, sync olarak çalışacak mantıklar içermektedir. Örnek vermek gerekirse, dosya okuma işlememiz sync/async olabilir ama, sonuç olarak elimizde olan değer string olduğu için, dosyayı dizi listesine çevirme işlemimiz hep aynı sync kod ile yapılıyor.&lt;/p&gt;

&lt;p&gt;Aynı şekilde network isteğimiz sync/async olabilir ama gelen string cevabı hep JSON&amp;rsquo;a parselayıp, içindeki title ve description bilgisini aynı şekilde alıyoruz. Ve ekrana yazma fonksiyonumuzda aynı şekilde hep aynı kalıyor.&lt;/p&gt;

&lt;p&gt;Bu fonksiyonları ayırıp, bir önceki async/await kodumuzu tekrar yazdığımızda böyle bir şey elde ediyoruz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Dosya okumak için node.js kütüphanemizi alalım.
const fs = require(&#39;fs&#39;);
// node.js error-first callbackleri Promise&#39;e çevirmemize yardımcı olan fonksiyon
const { promisify } = require(&#39;util&#39;);
// readFile error first async fonksiyonunu, promise döndürecek şekilde çeviriyoruz.
const readFilePromise = promisify(fs.readFile);
// promise döndürecek şekilde async istek yapmamızı sağlayacak olan kütüphane.
const request = require(&#39;request-promise-native&#39;);

function convertFileBufferToIDArray(buffer){
  return buffer.toString().split(&#39;\n&#39;);
}

// verilen string&#39;i json parse yaparak, film modeline çevirme işlemi.
function parseResponseToTitleAndDescription(resultStr){
  const body = JSON.parse(resultStr);
  return { title, description } = body;
}

// verilen başlık ve açıklamayı, konsola yazdırma
function outputMovieToConsole({ title, description }){
  console.log(`Film Adı: ${title}`);
  console.log(`Filmin açıklaması: ${description}`);
}

// string olarak gelen cevabı film modeline işle ve ekrana bastır.
function parseAndOutput(resultStr){
  const movie = parseResponseToTitleAndDescription(resultStr);
  return outputMovieToConsole(movie);
}

// sync benzeri kod yazabilmek için, async (promise döndüren) bir fonksiyon yazalım.
async function main(){
  // Dosya okuyan async kodu başlatalım, sonuctaki her bir satırı, dizi elemanı olarak alalım.
  const buffer = await readFilePromise(&#39;../data/ghibli_movies.txt&#39;);
  const movieIDs = convertFileBufferToIDArray(buffer);

  // Her bir dizi elemanı için async olarak istek gönderelim.
  for(let movieID of movieIDs){
    // API&#39;ye yaptığımız istek
    const resultStr = await request(`https://ghibliapi.herokuapp.com/films/${movieID}`);
    parseAndOutput(resultStr);
  }
}

// main fonksiyonunu çalıştır, ve dönen promise değerinde sonuç ve hata olması durumunda, konsola çıktı ver.
main().then(console.log, console.log);
// main fonksiyonunun bloklamadığını kanıtlamak için, ekrana yazı yazalım.
console.log(&#39;Main fonksiyonu çağrıldı!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uygulamamızın sabit mantığını fonksiyonlara taşıyarak, async içerisindeki kodu oldukca azalttık. Artık sync veya farklı bir şekilde kod yazsak bile, async kısma bulaşmayan kodumuz aynı çalışacak.&lt;/p&gt;

&lt;h3 id=&#34;promise-kullanarak-çoklu-işlemde-performansı-arttırmak&#34;&gt;Promise kullanarak çoklu işlemde performansı arttırmak&lt;/h3&gt;

&lt;p&gt;Bir Promise zinciri oluşturmak yerine, Promise oluşturma işlemini async await&amp;rsquo;e bırakmak yerine, kendimiz belirleyerek, daha performanslı bir kod elde edebiliriz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// sync benzeri kod yazabilmek için, async (promise döndüren) bir fonksiyon yazalım.
async function main(){
  // Dosya okuyan async kodu başlatalım, sonuctaki her bir satırı, dizi elemanı olarak alalım.
  const buffer = await readFilePromise(&#39;../data/ghibli_movies.txt&#39;);
  const movieIDs = convertFileBufferToIDArray(buffer);

  // Promise all kullanarak, aynı anda birden fazla async işlem başlatıp, hepsinin bitmesini bekleyebiliriz.
  // await ile bu işlemler bitmeden main fonksiyonunu sonlandırmak istemediğimiz söylüyoruz.
  await Promise.all(
      // her bir film id için,
      movieIDs.map((movieID) =&amp;gt; 
        // async bir işlem başlat
        request(`https://ghibliapi.herokuapp.com/films/${movieID}`)
          // bu işlem bittikten sonra, sonucu işle ve ekrana yazdır.
          .then(parseAndOutput)
      )
  )

  console.log(&#39;Main fonksiyonunun çalışması bitti.&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Main fonksiyonumuzu bu şekilde değiştirdikten sonra, film çekilme işleminin hızlandığını ve çıktıların sıralarının her çalıştırmada değiştiğini görüyoruz. Artık tüm network istekleri eş zamanlı olarak çalıştırılıyor ve ilk biten istek için işleme ve ekrana yazdırma işlemi yapılıyor.&lt;/p&gt;

&lt;p&gt;Özet olarak; async/await&amp;rsquo;in okunulabilirlik açısından sağladığı faydaların, Promise kullanımı bilmeden, performansı kötü etkileyici bir faktör olabildiğini, ve Promise primitivelerini kullanarak uygulamamızı hızlandırabileceğimizi gördük.&lt;/p&gt;

&lt;p&gt;Fakat şöyle bir sıkıntı var. Bu tarz bir yapıda, eş zamanlı olarak kaç işlem başlatabileceğimizin, işlemlerin iptal edilebilmesinin kontrolü bizde değil. Ne kadar Promise&amp;rsquo;ler ile çalışırken yardımcı kütüphaneler ile bu konularda biraz çözüm bulabilsekte, Promise&amp;rsquo;ler tek bir async veri ile çalışmak üzere geliştirildiği için bu konularda eksiklik çekiyoruz. Burada devreye; kurtarıcımız, RxJS giriyor.&lt;/p&gt;

&lt;h3 id=&#34;rxjs-ile-async-birden-fazla-film-işlemenin-yeniden-yazılması&#34;&gt;RxJs ile async, birden fazla film işlemenin yeniden yazılması&lt;/h3&gt;

&lt;p&gt;Promise&amp;rsquo;ler Async ve Tek veriler ile kullanıma uygun olduğu gibi, RxJS ise, async veri akışı ile çalışmak istediğimiz zamanda kullanılıyor. Promise&amp;rsquo;ler, error first callbackler için nasıl güzel bir alternatif ise, RxJs&amp;rsquo;de Node.JS streamleri için o kadar güzel bir alternatif. Promise&amp;rsquo;ler gelecekte başarılı veya başarısız olabilecek tekil verileri ifade ederkeen, RxJs oberservable pattern kullanarak, zaman bağlı olarak bir veri akışını ifade ediyor. RxJs&amp;rsquo;de Stream üzerindeki verileri tek tek işlemek için bir fonksiyon, hata olması durumunda başka bir fonksiyon ve Stream&amp;rsquo;in sonuçlanmasında farklı bir fonksiyon tanımlayabiliyorsunuz.&lt;/p&gt;

&lt;p&gt;RxJs Streamleri, Promise&amp;rsquo;ler gibi zincirlenme özelliklerine sahip, ve aynı zamanda kendi methodları içerisinde Promise&amp;rsquo;leride destekliyor. RxJs&amp;rsquo;in bir güzel özelliği ise, zamana bağlı işlemler için &lt;a href=&#34;http://reactivex.io/documentation/operators.html&#34;&gt;operator&lt;/a&gt; adını verdiği methodlar içermesi. Bu methodlar ile el ile implemente etmesi zor olan bir çok veri akışı işleme özelliğini bedavaya alıyorsunuz.&lt;/p&gt;

&lt;p&gt;Az önceki kodumuza, eş zamanlı olarak maksimum 5 istek çağırmayı ve eğer toplam işlem süresi 2 saniyeyi geçerse tüm istekleri durdurmayı ekliyelim:&lt;/p&gt;

&lt;p&gt;İlk önce rxjs&amp;rsquo;i projemize ekliyoruz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// rxjs kütüphanesini ekliyelim
const Rx = require(&#39;rxjs/Rx&#39;);
// kullanacağımız operatörleri alalım
const { mergeMap, takeUntil } = require(&#39;rxjs/operators&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Daha sonrada projemizin sadece Main fonksiyon kısmını değiştiriyoruz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const timeoutPromise = new Promise((resolve, reject) =&amp;gt; setTimeout(resolve, 2000));
// sync benzeri kod yazabilmek için, async (promise döndüren) bir fonksiyon yazalım.
async function main(){
  // Dosya okuyan async kodu başlatalım, sonuctaki her bir satırı, dizi elemanı olarak alalım.
  const buffer = await readFilePromise(&#39;../data/ghibli_movies.txt&#39;);
  const movieIDs$ = Rx.Observable.from(convertFileBufferToIDArray(buffer));

  // movieIDs streamini işlemek için bir hat oluştur, promise&#39;e döndür ve bitmesini bekle.
  await movieIDs$.pipe(
      // her akıştan gelen veri için, verilen fonksiyondaki işlemi yap.
      mergeMap((movieID) =&amp;gt;
        // movieID için istek gönder, sonucu işle.
        request(`https://ghibliapi.herokuapp.com/films/${movieID}`).then(parseAndOutput),
        undefined,
        // aynı anda en fazla 5 promise bekliyor durumda olsun.
        5
      ),
      // timeoutPromise bitene kadar çalış!
      takeUntil(timeoutPromise)
  ).toPromise();

  console.log(&#39;Main fonksiyonunun çalışması bitti.&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bunun sonucunda elde ettiğimiz scriptin, 2 saniyeden fazla çalışması durumunda kendini sonlandırdığını, ve anlık olarak en fazla 5 istek gönderdiğini görebiliriz. Umarım RxJs&amp;rsquo;in operatörleri sayesinde kafanızdaki fikirleri, sonlu/sonsuz bir veri akışı üzerinde gerçekleştirmenin ne kadar kolay olduğunu anlayabilmişsinizdir.&lt;/p&gt;

&lt;p&gt;Bu kullanım, JS dünyasında Thread olmadığı için, diğer dillere göre daha bir kolay ve eğlencelidir.&lt;/p&gt;

&lt;p&gt;Son oluşturduğumuz script&amp;rsquo;de küçük bir hata&amp;rsquo;da bulunmaktadır! Yaptığımız istekleri Promise olarak yaptığımız için, stream timeout sebebi ile sonlanması, Promise&amp;rsquo;ler cancel edilebilir olmadığı için, istekleri durduramamaktadır. Bunuda &lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/doc/operators/ajax.md&#34;&gt;RxJs.DOM.Ajax&lt;/a&gt; kullanarak çözebiliriz.&lt;/p&gt;

&lt;h2 id=&#34;çıkarımlar&#34;&gt;Çıkarımlar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bilgisayar donanımımızı ve kaynaklarımızı en optimize şekilde kullanmak için async işlem yapmaya ihtiyacımız vardır.&lt;/li&gt;
&lt;li&gt;Node.JS&amp;rsquo;in tek çekirdekli yapısı, dili parallelikten yoksun bırakırken, async olarak çalışmayı kolaylaştırmaktadır.&lt;/li&gt;
&lt;li&gt;Node.JS scriptleri birden fazla işlem olarak çalıştırılarak paralellik elde edilebilir.&lt;/li&gt;
&lt;li&gt;Sync/Async durumlara bağlı olmayan işlemlerinizi ayrıştırarak, ortak kullanılabilen fonksiyonlar oluşturabilirsiniz.&lt;/li&gt;
&lt;li&gt;Promise gibi yapılara dil seviyesinde uyumluluk sağlanarak, daha okunulabilir kod yazılabilir. Örn. async/await.&lt;/li&gt;
&lt;li&gt;Async tekli veriler için Promise kullanabilirsiniz. Async/Await syntaxı ile Promiseler ile, Sync kod&amp;rsquo;a benzer bir yapıya sahip olabilirsiniz, ama performans için her zaman iyi olmayabilir.&lt;/li&gt;
&lt;li&gt;Async/Await kullanırken, performans veya okunulabilirlik için Promise fonksiyonları kullanabilirsiniz.&lt;/li&gt;
&lt;li&gt;Sonlu veya sonsuz, async olarak işlenebilecek veri akışları için, Node.JS Stream&amp;rsquo;lerine alternatif olarak RxJS kullanabilirsiniz.&lt;/li&gt;
&lt;li&gt;RxJS operatörleri, zamana bağlı veri akışları ile çalışmayı kolaylaştırmaktadır. Ve Promiseler ile uyumlu bir şekilde çalışabilir.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>